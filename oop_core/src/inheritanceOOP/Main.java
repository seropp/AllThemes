package inheritanceOOP;


import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        Collection c = new HashSet();
        Main m = new Main();
        m.print(c);
    }

    public void print(Collection c) {
        System.out.println("Coll");
    }

    public void print(Set c) {
        System.out.println("S");
    }

    public void print(HashSet c) {
        System.out.println("Hs");
    }
}



    /*






    1. Overloaded
    2. Статическия привязка - компилятор(во время компеляции) проверяет сигнатуры методов,
                              определив наиболее подхоящий устанавливает статическую привязку
    3. Перегрузка методов связана ПОЛИМОРФИЗМ ВО ВРЕМЯ КОМПИЛЯЦИИ (ИЛИ ЖЕ СТАТИЧЕСКИЙ ПОЛИМОРФИЗМ)
    4. Перегрузка за счет:
          a. количества перемен. b. порядок перемен. c. типа перемен.
    5. Тип возвр. значения не учитывается при перегрузке
    6. Если у нас методы принимают один аргумент ссылочного типа, то возможна неоднозначность,
       если мы будем передавать method(null); но если Integer x = null; method(x); все хорошо
       два объекта с одного иерархиеского уровня => неоднозначность
       Родитель + ребенок => все хорошо
    7. при передачи примитива, возможно его повышение(понижение нет, т.к. возможны потери)
       byte -> примитивы -> обертки -> int ...
       char -> примитивы -> обертки -> int ...
    8. static методы можно перегружать
    9. метод main() можно перегрузить
    10. Перегрузка операторов недопустима
    11. Var-args (переменное число аргументов) Возможны различные варианты возникновения неоднозначностей












        1. inheritance  extends
           Java определяет отношение is-a между суперклассом и подклассом. Car is-a (это тоже) Vehicle.
           HAS-A - существует два вида отношения has-a:
                  > Композиция (класс содержит один или несколько объектов (экземпляров) другого класса.
                                Без этих объектов невозможно логическое существование самого класса.
                                НАПР.: Car has a Engine(У машины есть двигатель)
                  > Агрегация  (один или несколько вложенных объектов не являются частью класса даже 0)
                                Класс может содержать любое количество таких объектов (даже 0)
                                НАПР.: Car has a passengers

        2. Конструкторы не наследуются подклассами, но конструктор подкласса должен
           вызывать конструктор в суперклассе используя конструкцию super().
           Если конструкторы не определены, то всеравно происходит неявный вызов пустого конструктора супперкласса

        3. Поля и методы с модификаторами доступа по умолчанию (пакет) могут быть доступны для подклассов,
           только если он находится в том же пакете, что и суперкласс.
           а частные поля и методы суперкласса никогда нельзя ссылаться непосредственно,
           только через методы, достижимые из подкласса
        4. Множестевенное насследование только за счет интерфейсов
        5. Vehicle vehicle = new Car(); -> Процесс ссылки на объект класса как тип, отличный от самого класса,
                                           называется приведением типа. Вы бросаете объект из одного типа в другой.
           Truck truck = (Truck) vehicle; -> ClassCastException, во время выполнения
        6. Java содержит инструкцию с именем instanceof. (является ли данный объект экземпляром некоторого класса)
            car instanceof Vehicle
        7. Типы наследования:
           a.Single Inheritance  b.Multi Lever Inheritance
           c.Hierarchical Inheritance d.Множественное (в Java не поддерживается)

     */

    /*



        1. @Override - предупредит при отсутстви метода
           За счет переопределения достигается ПОЛИМОРФИЗМ во время выполнения (полиморфизм времени выполнения)
        2. Переопределение - это ДИНАМИЧЕСКАЯ ПРИВЯЗКА. Компилятор должен определить тип, чтобы понять какой
            метод нужно вызывать. А эта проверка происходит во время выполнения
            (Перегрузка - СТАТИЧЕСКАЯ ПРИВЯЗКА. Выбор метода во время компиляции, через сравнение аргументов)

        3. При переопределении необходимо соблюдать следующие условия:
           * Количество, порядо и тип аргументов должны совпадать
           * Тип возвращаемого значения(ссылочных объ.) должен находится ниже или на одном иерархическом уровне
           * Модификатор доступа не должен быть строже чем у метода суперкласса
           * если переопределенный метод должен иметь в своей сигнатуре throws,
             то метод суперкласса должен името throws + искл., которое находится на одном уровне или выше
             в иерархии искл. (На Error не расспостраняется).
             Если род метод имеет throws, переопред. метод не обязан иметь throws

        4. Переопределенный метод вызывается на основе обрабатываемого ОБЪЕКТА, а не по типу ССЫЛКИ
                                  Person person = new Employ();
                                  person.info(); => метод определенный в классе Employ
           Отсюда следует, что для методов класса (статических м.), метод вызывается согласно типу ссылки
           а для методов экзэмпляра - в соответствии с типом объекта, во время выполнения
           JVM динамически находит и вызывает именно ту версию метода, которая определена в подклассе - это ДДМ
           (Благодаря ДИНАМИЧЕСКОЙ ДИСПЕТЧЕРИЗАЦИИ МЕТОДОВ реализуется ПОЛИМОРФИЗМ КЛАССОВ В JAVA)

        5. НЕ МОГУТ БЫТЬ ПЕРЕОПРЕДЕЛЕННЫ
            - static
            - final (getters and setters, чтобы избежать непреднамеренного переопределения)
            - private
            - конструкторы (имя конструктора, должно совподать с названием класса)

        6 Если подкласс находится в др. пакете могут быть переопределенны только (protected и public НО НЕ по умолчанию)






    */