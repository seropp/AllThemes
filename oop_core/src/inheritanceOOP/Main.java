    package inheritanceOOP;

    import java.io.IOException;
    import java.sql.SQLDataException;

    public class Main {
        public static void main(String[] args) {
            Person p = new Person();
            p.method();
            Employ e = new Employ();
            e.method();
            e.method1();
        }
    }

    class Person {
        final void method() {
            System.out.println("sss");
        }

        void method1() {
            System.out.println("ssswww");
        }
    }

    class Employ extends Person {

    }

    class XXX extends Employ {
    }
    /*


        1. inheritance  extends
           Java определяет отношение is-a между суперклассом и подклассом. Car is-a (это тоже) Vehicle.
           HAS-A - существует два вида отношения has-a:
                  > Композиция (класс содержит один или несколько объектов (экземпляров) другого класса.
                                Без этих объектов невозможно логическое существование самого класса.
                                НАПР.: Car has a Engine(У машины есть двигатель)
                  > Агрегация  (один или несколько вложенных объектов не являются частью класса даже 0)
                                Класс может содержать любое количество таких объектов (даже 0)
                                НАПР.: Car has a passengers

        2. Конструкторы не наследуются подклассами, но конструктор подкласса должен
           вызывать конструктор в суперклассе используя конструкцию super().
           Если конструкторы не определены, то всеравно происходит неявный вызов пустого конструктора супперкласса

        3. Поля и методы с модификаторами доступа по умолчанию (пакет) могут быть доступны для подклассов,
           только если он находится в том же пакете, что и суперкласс.
           а частные поля и методы суперкласса никогда нельзя ссылаться непосредственно,
           только через методы, достижимые из подкласса
        4. Множестевенное насследование только за счет интерфейсов
        5. Vehicle vehicle = new Car(); -> Процесс ссылки на объект класса как тип, отличный от самого класса,
                                           называется приведением типа. Вы бросаете объект из одного типа в другой.
           Truck truck = (Truck) vehicle; -> ClassCastException, во время выполнения
        6. Java содержит инструкцию с именем instanceof. (является ли данный объект экземпляром некоторого класса)
            car instanceof Vehicle
        7. Типы наследования:
           a.Single Inheritance  b.Multi Lever Inheritance
           c.Hierarchical Inheritance d.Множественное (в Java не поддерживается)

     */

    /*



        1. @Override - предупредит при отсутстви метода
           За счет переопределения достигается ПОЛИМОРФИЗМ во время выполнения (полиморфизм времени выполнения)
        2. Переопределение - это ДИНАМИЧЕСКАЯ ПРИВЯЗКА. Компилятор должен определить тип, чтобы понять какой
            метод нужно вызывать. А эта проверка происходит во время выполнения
            (Перегрузка - СТАТИЧЕСКАЯ ПРИВЯЗКА. Выбор метода во время компиляции, через сравнение аргументов)

        3. При переопределении необходимо соблюдать следующие условия:
           * Количество, порядо и тип аргументов должны совпадать
           * Тип возвращаемого значения(ссылочных объ.) должен находится ниже или на одном иерархическом уровне
           * Модификатор доступа не должен быть строже чем у метода суперкласса
           * если переопределенный метод должен иметь в своей сигнатуре throws,
             то метод суперкласса должен името throws + искл., которое находится на одном уровне или выше
             в иерархии искл. (На Error не расспостраняется).
             Если род метод имеет throws, переопред. метод не обязан иметь throws

        4. Переопределенный метод вызывается на основе обрабатываемого ОБЪЕКТА, а не по типу ССЫЛКИ
                                  Person person = new Employ();
                                  person.info(); => метод определенный в классе Employ
           Отсюда следует, что для методов класса (статических м.), метод вызывается согласно типу ссылки
           а для методов экзэмпляра - в соответствии с типом объекта, во время выполнения
           JVM динамически находит и вызывает именно ту версию метода, которая определена в подклассе - это ДДМ
           (Благодаря ДИНАМИЧЕСКОЙ ДИСПЕТЧЕРИЗАЦИИ МЕТОДОВ реализуется ПОЛИМОРФИЗМ КЛАССОВ В JAVA)

        5. НЕ МОГУТ БЫТЬ ПЕРЕОПРЕДЕЛЕННЫ
            - static
            - final (getters and setters, чтобы избежать непреднамеренного переопределения)
            - private
            - конструкторы (имя конструктора, должно совподать с названием класса)

        6 Если подкласс находится в др. пакете могут быть переопределенны только (protected и public НО НЕ по умолчанию)






    */