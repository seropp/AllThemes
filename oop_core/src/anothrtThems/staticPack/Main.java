package anothrtThems.staticPack;

public class Main {


    private static Integer staticValue = 99;
    private Integer simpleValue = 99;

    public static void main(String[] args) {
        System.out.println(new Main().simpleValue);
    }
}


/*
    Static METHODS
    1. Т.к. static methods можно вызывать без создания нового объекта класса, Их широко применяют
       для создания классов утилит (кл. утилиты final) напр.: Math, Arrays, Collections
    2. static методы нельзя переопределять

    3. static method in the INTERFACE:
             1. с Java8 можно опр. static мет. в интерфейсах
             2. похожи на default мет. интерфейсов, но имеют существенные различия (default - можно переопредлить)
             3. чтобы исп. static метод интерфейса не нужно использовать implements
    Подробности о static methods:
        1. Статические методы в Java вызываются во время компиляции.
        2. Абстрактные методы не могут быть статическими
        3. Статические методы не могут использовать ключевые слова this или super
        4. Методы экземпляра также могут непосредственно обращаться к статическим переменным и статическим метода
        5. Статические методы могут обращаться ко всем статическим переменным и другим статическим методам (не к экз.)
        6. Статические методы не могут напрямую обращаться к переменным экземпляра и методам экземпляра.
           Для этого им нужна ссылка на объект
        7. Связываются во время компиляции. => метод в кл. наследнике будет не переопределен, а
           перекрыт (hiding methods)
        8.

       (static Object obj = new Object(); -- ссылка на obj хранится в MetaSpace, а сам объект в Heap)




   Статические переменные могут быть объявлены только на уровне класса, доступны без инициализации объекта
   1. static поля являются общими для всего класса (испю без создания экз. класса) => исп this или super НЕ ЖЕЛАТЕЛЬНО
   2. Константы объявляют как static (напр out, in, PI)
   3. static переменные размещаются в специальном пуле в памяти JVM, называемом Metaspace
        (до Java 8 он назывался Permanent Generation или PermGen, который был полностью удален и заменен на Metaspace).

   4. Т.к. static перем. отн. к классу, то они не могут быть сериализованы и просто игнорируются.
        для сериализации и десериализации должны быть определенны отдельные классы!!!!!!
        static переменная передает значение, которое получило при загрузке класса (а transient нет);
        static String company = "Itr";
        или же через, блок инициации, ПРИ ЭТОМ ОН ДОЛЖЕН БЫТЬ STATIC или инициализация не пройдет !!!!!!!
        static{company = "ITR"}
        Если использовать с переменной static и transient, то
        управлять поведением переменной будет модификатор static, а не Transient.

    5. static переменные и методы не потокобезопасны!!!!
        если мы хотим безопасно их использовать нужно залочить класс. Это делается слеующим образом:
        a. для исп. класса в многопот. он должен implements Runnable, и соответственно реализовать метод run()
        b. в методе run() мы должны первым делом вызывать наш (ранее определенный метод),
           в котором произойдет залочивание через следующую конструкцию:
           private void Lock(){
                synchronized (Main.class){}
           }
    6. static переменные и методы можно вызывать по нулевой ссылке (спецификация разрешает)

    Shadowing in Java - затемнение в Java (Переменая нижнего уровня перекрывает перменные верхнего уровня)
    Статическая переменная задействует память только один раз, во время загрузки класса.
    Использовать static нужно в случае:
        Когда значение переменной не зависит от объектов
        Когда значение должно быть общим для всех объектов



    stat
 */