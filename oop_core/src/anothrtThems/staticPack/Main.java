package anothrtThems.staticPack;

public class Main {
    {
        System.out.print("b1 ");
    }

    public Main() {
        System.out.print("b2 ");
    }
}

class Raptor extends Main{
    static {
        System.out.print("r1 ");
    }

    public Raptor() {
        System.out.print("r2 ");
    }

    {
        System.out.print("r3 ");
    }

    static {
        System.out.print("r4 ");
    }
}

class Hawk extends Raptor {
    public static void main(String[] args) {
        System.out.print("pre ");
        new Hawk();
        System.out.println("hawk ");
    }
}


/*  
    Переменные в Java
    A. Локальные переменные B. Переменные экземпляра C. Статические переменные или переменные класса.

    Локальные
    1. Л.п. объявляются в методах, конструкторах или блоках.
    2. Л.п. создаются, когда м. к. или б. запускается и уничтожаются после того, как завершиться м., к. или б.
    3. Л.п. не могут иметь Модификаторы доступа
    4. Л.п. видимыми только в пределах объявленного м., к. или б.
    5. Л.п. - По отношению  к объектам: в Java 6 появилась пара "Escape Analysis и Scalar Replacement",
        которые делают следующее:
        a. E.A. проводит статический (во время компиляции) анализ. где проверяет достижимость созданного,
            в каких-либо рамках(м. к. б.) объекта из других частей програмы. И если ответ нет то...
        b. то S.R. проецирует поля объекта в локальные переменные
           (берем объ. и говорим, что в куче его не нужно создавать, а мы можем просто
            взять его поля и положить в локальные переменные) Эта пара работает по умолчанию
            Можно назвать это "статическим GC", тоесть пара EA-SR делает работу GC во время комп. а не рантайма
            (упрощает жизнь сборщику мусора.)
       А примитивы всегда хранятся в Stack
    6. В Java для локальных переменных значения по умолчанию не существует

    Переменные экземпляра
    1. Объявляются в классе
    2. Создаются в момент создания экземпляра класса, в который они входят и уничтожаются вместе с экземпляром.
    3. Могут быть объявлены до или после использования.
    4. Видны для всех методом, блоков и конструкторов внутри класса.
    5. Могут иметь модификаторы доступа (для них в осн. private)
    6. Имеют значения по умолчанию
    7. В нетри класса доступ просто через имя переменной, в др. кл. ПО полному имени или getter

    Статические переменные - ОТДЕЛЬНЫЙ СКРИНШОТ
    



    Статические и не статическе блоки инициализации
    
    ИНИЦИАЛИЗАЦИЯ В JAVA



    1. Инициализация по умоланию  (неявная инициализация ТОЛЬКО ДЛЯ ПЕРЕМЕННЫХ КЛАССА)
       В Java не существует значения по умолчанию для локальных переменных !!!
    2. Явная инициализация начальными значениями
       при явной инициализации final переменной есть 2 варианта в зависимости от типа
       a. Локальную, сначала можно объявить, а потом инициализировать
       b. Переменную опр. в классе нужно инициализировать сразу либо, через конструктор или блок иниц.
    3. static переменные инициализируются раньше переменных экземпляра
    4. через блоки инициализируются переменные экз. и переменные класса(static блоки
       выполняются по очереди перед конструктором.
       если вызвать static Class obj = new Class();, то конструктор вызовется раньше
    5. для инициализации и заполнения массивов лучше использовать блоки инициалзации, вместо методов
       => повышение производительности
   Блоки ИНИЦИАЛИЗАЦИИ
    1. Для увеличения мощности конструктора
    2. Блок инициализации является дополнением к конструктору.
    3. Java не позволяет бросить проверенное исключение из блока статической инициализации
       т.к. невозможно обработать эти проверенные исключения

    Static import
    1. Позволяет импортировать все статические членны класса (и исп. их без указывания на класс)
    2. Это упрощает и сокращает синтаксис,У
    3. Наиболее часто встречается в JUnit (исп. для assert методов)












    1. Т.к. static methods можно вызывать без создания нового объекта класса, Их широко применяют
       для создания классов утилит (кл. утилиты final) напр.: Math, Arrays, Collections
    2. static методы нельзя переопределять

    3. static method in the INTERFACE:
             1. с Java8 можно определять static методы в интерфейсах
             2. похожи на default мет. интерфейсов, но имеют существенные различия (default - можно переопредлить)
             3. чтобы исп. static метод интерфейса не нужно использовать implements
             4. => вызов через Имя интерфейса

    Подробности о static methods:
        1. Статические методы в Java вызываются во время компиляции.
        2. Абстрактные методы не могут быть статическими
        3. Статические методы не могут использовать ключевые слова this или super
        4. Методы экземпляра также могут непосредственно обращаться к статическим переменным и статическим метода
        5. Статические методы могут обращаться ко всем статическим переменным и другим статическим методам
        6. Статические методы не могут напрямую обращаться к переменным экземпляра и методам экземпляра.
           Для этого им нужна ссылка на объект
        7. Связываются во время компиляции. => метод в кл. наследнике будет не переопределен, а
           перекрыт (hiding methods)


       (static Object obj = new Object(); -- ссылка на obj хранится в MetaSpace, а сам объект в Heap)





   Статические переменные могут быть объявлены только на уровне класса, доступны без инициализации объекта
   1. static поля являются общими для всего класса (испю без создания экз. класса) => исп this или super НЕ ЖЕЛАТЕЛЬНО
   2. Константы объявляют как static (напр out, in, PI)
   3. static переменные размещаются в специальном пуле в памяти JVM, называемом Metaspace
        (до Java 8 он назывался Permanent Generation или PermGen, который был полностью удален и заменен на Metaspace).

   4. Т.к. static перем. отн. к классу, то они не могут быть сериализованы и просто игнорируются.
        для сериализации и десериализации должны быть определенны отдельные классы!!!!!!
        static переменная передает значение, которое получило при загрузке класса (а transient нет);
        static String company = "Itr";
        или же через, блок инициации, ПРИ ЭТОМ ОН ДОЛЖЕН БЫТЬ STATIC или инициализация не пройдет !!!!!!!
        static{company = "ITR"}
        Если использовать с переменной static и transient, то
        управлять поведением переменной будет модификатор static, а не Transient.

    5. static переменные и методы не потокобезопасны!!!!
        если мы хотим безопасно их использовать нужно залочить класс. Это делается слеующим образом:
        a. для исп. класса в многопот. он должен implements Runnable, и соответственно реализовать метод run()
        b. в методе run() мы должны первым делом вызывать наш (ранее определенный метод),
           в котором произойдет залочивание через следующую конструкцию:
           private void Lock(){
                synchronized (Main.class){}
           }
    6. static переменные и методы можно вызывать по нулевой ссылке (спецификация разрешает)

    Shadowing in Java - затемнение в Java (Переменая нижнего уровня перекрывает перменные верхнего уровня)
    Статическая переменная задействует память только один раз, во время загрузки класса.
    Использовать static нужно в случае:
        Когда значение переменной не зависит от объектов
        Когда значение должно быть общим для всех объектов



    stat
 */