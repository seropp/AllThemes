package accesModifications;

import java.util.ArrayList;
import java.util.List;

public class Main {



    public static void main(String[] args) {
        System.out.println(new Object() instanceof String);
        System.out.println(new String() instanceof Object);
    }
}

/*




    1. Могут быть
        -Класс - final класс не может иметь наследников;
        -Методы - final метод не могут быть переопределены в классах наследниках;
        -Поля  - не могут изменить свое значение после инициализации;
        -Параметры методов - не могут изменять своё значение внутри метода;
        -Локальные переменные - не могут быть изменены после присвоения им значения
    2. Инициализация final полей
        a. Прямая инициализация
        b. Через метод
        c. В блоке инциализации
        d. В конструкторе
        ПОВТОРНАЯ ИНИЦИАЛИЗАЦИЯЗАПРЕЩЕНА
    3. final поля явл константами. и обычно их делают Static, чтобы не создавать ее отд. для каждого объекта
    4. поля интерфейса по умолчанию явл. public + static + final
    5. Методы интерфейсаов не могут быть final (если только не private + final, но это бессмысленно)




   | assert | native | volatile
    assert
    1. добавлено в Java 1.4
    2. Утверждения являются инструментами только на этапе разработки.
       указывают на ошибку или неправильное использование пути кода. Приводит к аварийному завершению программы
    3. выбрасывает AssertionError
    4. имеет следующую структуру
            assert boolean exercise : "string";
    5. Java Исключения-это аналогичная концепция, но они не могут проверить все.
       Если вы хотите еще больше проверок (за счет скорости выполнения), вам нужно использовать утверждения.
    6. по умолчанию отключена (нужно изменить конф. запуска)

    native
    1. сигнализирует о том, что метод реализован в платформо-зависимом коде.

    volatile
    1. для многопоточек
    2. volatile -это один из способов обеспечения согласованного доступа к переменной разными потоками
    3. А именно, гарантирует, что значение переменной volatile всегда будет считаться из основной памяти,
       а не из локального кэша Thread
    4. => потокобезопасность (для примитивов)
       а, для ссылок - синхронизировано будет исключительно значение этой ссылки.
       Все же данные, содержащиеся в объекте, синхронизированы не будут!
    
    


 */